<!DOCTYPE html>
<html data-wf-domain="paolos-fabulous-project-e74cab96af4b9fc.webflow.io" data-wf-page="5cfd93a271000a535c533f97" data-wf-site="5cfd93a271000a4eb8533f96" data-wf-status="1" class="w-mod-js w-mod-ix wf-lato-n1-active wf-lato-i1-active wf-lato-n3-active wf-lato-i3-active wf-lato-n4-active wf-lato-i4-active wf-lato-n7-active wf-lato-i7-active wf-lato-n9-active wf-lato-i9-active wf-ptserif-n4-active wf-ptserif-i4-active wf-ptserif-n7-active wf-ptserif-i7-active wf-inconsolata-n4-active wf-inconsolata-n7-active wf-oswald-n2-active wf-oswald-n3-active wf-oswald-n4-active wf-oswald-n5-active wf-oswald-n6-active wf-oswald-n7-active wf-robotomono-n4-active wf-roboto-n4-active wf-active">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Spacecraft Flight Simulator | Paolo Arguelles</title>
    <meta content="width=device-width, initial-scale=1" name="viewport">
    <meta content="Webflow" name="generator">
    <link href="./website/style.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="./website/fonts.css" media="all">

    <style>
       /* Style the header with a grey background and some padding */
    .header {
      overflow: hidden;
      background-color: #f1f1f1;
      padding: 20px 50px;
    }

    /* Style the header links */
    .header a {
      float: left;
      color: black;
      text-align: center;
      padding: 12px;
      text-decoration: none;
      line-height: 25px;
      border-radius: 4px;
      transition: color 200ms;
    }

    .header a:hover {
      color: #DE5021;
    }

    /* Float the link section to the right */
    .header-right {
      float: right;
      font-size: 12px;
    }

    .myHeader {
      float: left;
      font-family: 'Palatino Linotype', 'Book Antiqua', Palatino, serif;
      font-size: 30px;
      color: #000;
    }

    .myPages {
      float: left;
      font-family: 'Futura';
      color: #000;
      font-size: 20px;
    }

    .project_image {
    	height: 600px;
    	margin-top: 0px;
    	padding-top: 0px;
    	background-image: url("./website/resources/pics/ssds_bg.jpg");
    	background-position: 50% 40%;
    	background-size: cover;
    	background-attachment: fixed;
    	line-height: 30px;
    }

    .collapsible {
      background-color: #fff;
      color: black;
      font-family: 'Futura';
      cursor: pointer;
      padding: 18px;
      width: 100%;
      border: none;
      text-align: left;
      outline: none;
      font-size: 18px;
      border-bottom-style: solid;
      border-bottom-color: inherit;
    }

    .column {
  float: left;
  width: 33.33%;
  padding: 5px;
}

/* Clearfix (clear floats) */
.row::after {
  content: "";
  clear: both;
  display: table;
}

    .active, .collapsible:hover {
      transition: 200ms;
      color: #DE5021;
    }

    .collapsible:after {
      content: '+';
      font-weight: bold;
      float: right;
      margin-left: 5px;
      color: inherit;
    }

    .active:after {
      content: "−";
      color: #DE5021;
    }

    .content {
      padding: 0 18px;
      max-height: 0;
      overflow: hidden;
      transition: max-height 300ms;
      background-color: #f1f1f1;
    }

    .sidenav {
    font-family: 'Palatino';
    font-size: 18px;
    font-weight: 400;
    color: black;
    height: 50%;
    width: 400px;
    z-index: 1;
    top: 0px;
    position: relative;
    background-color: transparent;
    overflow-x: hidden;
    padding-top: 20px;
    padding-left: 40px;

    }

.sidenav a {
  font-family: 'Helvetica';
  padding: 6px 40px 6px 0px;
  text-decoration: none;
  font-size: 14px;
  font-weight: bold;
  color: black;
  display: block;
}

.sidenav d {
  font-family: 'Helvetica';
  padding: 6px 40px 6px 0px;
  text-decoration: none;
  font-size: 14px;
  font-weight: bold;
  color: black;
  display: block;
}

.sidenav a:hover {
  transition: 200ms;
  color: #DE5021;
}

.main {
  margin-left: 160px; /* Same as the width of the sidenav */
  font-size: 28px; /* Increased text to enable scrolling */
  padding: 0px 10px;
}




    /* Add media queries for responsiveness - when the screen is 500px wide or less, stack the links on top of each other */
    @media screen and (max-width: 500px) {
      .header a {
        float: none;
        display: block;
        text-align: left;
      }
      .header-right {
        float: none;
      }
    }
    </style>
</head>

<body class="body-2">
  <div class="header">
  <a href="./index.htm" class="myHeader">Paolo Arguelles</a>
  <div class="header-right">
    <a class=myPages href="./projects.htm">PROJECTS</a>
    <a class=myPages href="./bio.htm">BIOGRAPHY</a>
    <a class=myPages href="https://drive.google.com/open?id=1AKRUojt-o0aw6FJ4KOZ0L28iyKNJUinO">SPEECH</a>
    <a class=myPages href="https://drive.google.com/file/d/13bpb_zUXokdzU9XViRuhRjnIcB8op8Bh/view?usp=sharing">RESUME</a>
  </div>
  </div>

    <div class="project_image">
    </div>
    <div class="sidenav">
      <a href="./projects.htm" text-align:"center"> ‹ Back to Projects </a>
<br>
      Project Name
      <d>Spacecraft Flight Simulator and Attitude Testbed</d>
      <br>
      Status
      <d>COMPLETED MAY 2019</d>
      <br>
      Affiliations
      <br>
      <a href="https://www.spacecraftresearch.com/people/">Space Systems Design Studio, Sibley School of Mechanical and Aerospace Engineering, Cornell University
      <br></a>
      <br>
      Documentation
      <a href="https://drive.google.com/file/d/1NxzaLj2ZQ5mfK8Np1Bqytdaup1xIWbcF/view?usp=sharing">Operating Manual</a>
      <a href="https://drive.google.com/file/d/1jhVrCEwU1HlSFq-RFkDKwWMvN3YjMn6Y/view?usp=sharing">Initial Testing Report</a>
      <a href="https://drive.google.com/file/d/1zLbBJRLDpb3ArYOebd8V6Li6tWvDFnFl/view?usp=sharing">COMS Subsystem Progress Report Slides</a>

    </div>
    <div class="project_box">
      <div class="project_contain">
        <div class="project_topic"> SPACE AND DEFENSE </div>
        <div class="project_title">
        Spacecraft Flight Simulator and Attitude Testbed
        </div>
        <div class="project_description">
          Built for Cornell's Space Systems Design Studio, this project consists of a remotely controlled testbed containing six onboard thrusters and three reaction wheels to simulate multi-axis orbital dynamics of spacecraft in a frictionless environment.        </div>
        <div class="project_body">
          <h1 class="project_body_header">
            Simulating Outer Space in a Lab Environment
          </h1>

          The idea is to simulate spacecraft control by developing a physical system that mimics the friction-free environment of outer space and is able to rotate in three axes. The system we built is suspended on an air bearing which levitates the system on a thin layer of air (like an air hockey puck). Our system is controlled via three reaction wheels (motors that turn spacecraft by gyroscopic effects) and six compressed air thrusters.           The electronics are controlled wirelessly from a nearby computer with a custom-built graphical user interface.
          <br><br>
          <img src="./website/resources/pics/fullsetup.jpg" height=500px class="center">
          <figcaption class="caption">Complete lab test setup of the simulator and testbed</figcaption>
          <br>
          The <i> Spacecraft Flight Simulator and Attitude Testbed </i> will provide a lab environment to test autonomous attitude control algorithms for the small spacecraft developed in our research lab, as well as provide professors with an instructional platform for advanced spacecraft control students.

        <h1 class="project_body_header">
          Hardware Details
        </h1>
        <i> Explore testbed components and subsystems. </i>
        <button class="collapsible">SIMULINK CONTROL INTERFACE</button>
        <div class="content"><br>
          <img src="./website/resources/pics/interface.png" height=500px class="center">
          <figcaption class="caption">User interface for the spacecraft flight simulator</figcaption>
          <h2 class="project_body_subheader">
            Design
         </h2>

          <p>Because the data stream has been formatted such that it is sent to the Simulink program serially, it is relatively trivial to parse the incoming string and extract desired values. The Simulink program makes use of the Serial Instrumentation blockset to interface with an XBee plugged directly into the computer. Upon simulation execution, Simulink recognizes the XBee as a COM device, establishes a connection, and begins reading the raw data strings sent by the Arduino.</p>

          <img src="./website/resources/pics/scope.png" height=700px class="center">
          <figcaption class="caption">Realtime telemetry visualization</figcaption>

        </div>
        <button class="collapsible">FLIGHT COMPUTER</button>
        <div class="content"><br>
          <p>The FLIGHT COMPUTER retains the following roles:
            <ul>
                <li>Receives and interprets commands sent wirelessly to the testbed by an operator</li>
                <li>Sends instructions to the REACTION WHEEL CONTROLLER and THRUSTER CONTROLLER to execute operator commands </li>
                <li>Receives realtime telemetry from the inertial measurement unit (IMU) and pressure sensor</li>
                <li>Detects pulse information from three optical tachometers and calculates corresponding reaction wheel speed readings</li>
                <li>Transmits inertial telemetry, reaction wheel speeds, and pressure readings back to the operator
            </ul>

            <h2 class="project_body_subheader"> Switching from Arduino Due to Raspberry Pi </h2>
            Previous teams' designs called for an Arduino Due to act as the flight computer. However, after compiling a requirement set for the flight computer, I realized that an Arduino Due is not sufficient to realize the requirement set
            and instead opted for a Raspberry Pi 3B+. This switch enabled me to take advantage of a number of new capabilities including multithreading (enabling multiple processes to run concurrently, a desired trait for realtime hardware applications), increased clock speed for faster code execution, and the benefit of an entire Linux-based embedded operating system fully contained on the testbed.
            Each Arduino microcontroller acting as a peripheral device was plugged directly into the Raspberry Pi USB hub and would achieve bidirectional communication with the flight computer over a UART bus.

            <h2 class="project_body_subheader"> <br>Transmitting Telemetry</h2>
            A primary task of the flight computer is to relay telemetry from the onboard IMU sensor back to the operator. The flight computer achieves this by
            reading serial data from the IMU reader microcontroller to gather inertial telemetry and using a FIFO to collect reaction wheel speed calculated by another Python script running in the background. The program then compiles an ASCII string and transmits it to the operator over the local XBee link.
            <img src="./website/resources/pics/telemetry.png" height=300px class="center">
            <figcaption class="caption">Transmitted strings containing wheel speeds and inertial telemetry</figcaption>

            Each line carries information about the speed of each reaction wheel, and accelerometer, gyroscope, and magnetometer readings in three axes from the IMU sensor.
            This serial stream is captured and parsed in Simulink where the resulting information is displayed to the operator in a readable manner.
            <h2 class="project_body_subheader"> <br>Persistent Serial Device Identification </h2>
            Each COM device had to be configured in the Raspbian kernel to always be identified with a constant name. However, the operating system randomly assigns names (e.g., /dev/tty0) depending on which Arduino was recognized first. I introduced u-dev rules to capture uniquely identifying id values for each connected COM device and used SYMLINKs to create an identifying name (e.g., /dev/imu_reader, /dev/motor_controller, etc.) that uniquely and persistently identifies each microcontroller.

          </p>
        </div>
        <button class="collapsible">CONTROLLING THE THRUSTERS</button>
        <div class="content">
          <p><br>The six solenoid valves controlling each of the six thrust outlets are each connected to a logic-level MOSFET driven by an Arduino microcontroller.
          Code on the microcontroller limits each thrust duration to 200 ms. </p>

          <img src="./website/resources/pics/valves.jpg" height=300px class="center">
          <figcaption class="caption">MOSFET drivers to control thrusters</figcaption>

          The microcontroller controlling the propulsion subsystem is also connected to a pressure transducer which monitors the air pressure within the manifold that channels air from the tanks to the thruster outlets. If the pressure dips below a certain threshold, an LED
          signalling that the tanks need to be refilled. The warning light turns off when the air pressure returns to its nominal range.


          <img src="./website/resources/pics/transducer.jpg" height=300px class="center">
          <figcaption class="caption">Transducer in-line with manifold</figcaption>

          <img src="./website/resources/pics/tanks.jpg" height=300px class="center">
          <figcaption class="caption">Onboard compressed air tanks</figcaption>


        </div>
        <button class="collapsible">DRIVING THE REACTION WHEELS</button>
        <div class="content">
          <p><br>

          The testbed contains three high-torque DC pancake motors that act as reaction wheels. The reaction wheels were affixed orthogonally to each other to effect torques around three axes.
          <img src="./website/resources/pics/reactionwheels.jpg" height=300px class="center">
          <figcaption class="caption">Reaction wheels and optical tachometers</figcaption>

          An optical tachometer was carefully aimed at the spindle of each motor (which held a piece of reflective tape) to count revolutions. The optical tachometers were connected electrically to the flight computer's GPIO, where a pulse resulting from one revolution would trigger an interrupt service routine that updates an RPM value and sends it to the operator.
          Additionally, each reaction wheel was driven by a motor driver that actively monitors temperature, voltage, and current and cuts power to the load when a prespecified shutoff event is detected.          <br>

          <img src="./website/resources/pics/drivers.jpg" height=300px class="center">
          <figcaption class="caption">Motor drivers and Raspberry Pi flight computer</figcaption>

          Constraints were also placed on the brake ability of the reaction wheels (i.e., limits for acceleration/deceleration were put in place) to prevent large, sudden current draws.
          The reaction wheel direction and speed are both controlled by an 8-bit integer; a value of '128' sent by the operator to a reaction wheel on the testbed corresponds to zero rotation, '255' to full-speed (3600 RPM) clockwise, and '0' to full-speed counter-clockwise.
        </p>
        </div>

        <h1 class="project_body_header">
          Continuing Work
         </h1>
         <h2 class="project_body_subheader">
           Autonomous (Closed-Loop) Control
        </h2>
        Having built and successfully demonstrated open-loop control on the testbed to faculty members in the Sibley School of Mechanical and Aerospace Engineering, students from Professor Mason Peck's graduate spaceflight course were tasked with creating a closed-loop attitude control algorithm in simulation and deploying the controller to our hardware testbed for verification.
        The Simulink control program may be simplified to a single subsystem that effectively acts as a plant in a closed-loop control system.
        <br><br>
        <img src="./website/resources/pics/block.png" height=300px class="center">
        <figcaption class="caption">User interface as control plant</figcaption>
        A controller block may interface with the plant to achieve closed-loop and hardware-in-the-loop control. The controller block should consist of nine outputs: six valve state instructions (0 or 1) and three reaction wheel speed instructions (0-255). The block outputs accelerometer, gyroscope, magnetometer, and reaction wheel speed data in all three axes.

        <h1 class="project_body_header">Our Team </h1>
        <img src="./website/resources/pics/ssds_team.jpg" height=500px class="center">
        <figcaption class="caption">Testbed Team (left to right) — Bettina Aristorenas (Team Lead, Mechanical Engineer), Paolo Arguelles (Electrical & Computer Engineer), and Zach Tretler (Mechanical Engineer)</figcaption>
        <script>
        var coll = document.getElementsByClassName("collapsible");
        var i;

        for (i = 0; i < coll.length; i++) {
          coll[i].addEventListener("click", function() {
            this.classList.toggle("active");
            var content = this.nextElementSibling;
            if (content.style.maxHeight){
              content.style.maxHeight = null;
            } else {
              content.style.maxHeight = content.scrollHeight + "px";
            }
          });
        }
        </script>

        </div>
      </div>

      </div>
  </div>

    <div class="section-8">
        <div class="text-block-6">© 2019 - 2023 by Paolo Arguelles. All rights reserved.<br></div>
    </div>

</body>

</html>
